{"data":{"site":{"siteMetadata":{"title":"Michael Blog","author":"Michael Luo"}},"markdownRemark":{"id":"1264e1aa-665d-5038-b369-d5793dd48ae2","excerpt":"Notes for authendication Sessions Client - session cookies\nServer - session-state service/server/manager problem: Memory issues: Whenever there are many…","html":"<h1>Notes for authendication</h1>\n<h2>Sessions</h2>\n<p>Client - session cookies\nServer - session-state service/server/manager</p>\n<p>problem:</p>\n<ul>\n<li>Memory issues: Whenever there are many authenticated users, the we server will consume more and more memory. Even if we use a file-bnased or external session provider, there will nonetheless be an intensive io, tcp, or socket overhead.</li>\n<li>Scalability issues: Replicating a session provider in a scalable web farm might not be an easy task and will often lead to bottlenecks or wasted resources.</li>\n<li>Cross-domain issues: Session cookies behave just like standard cookies, so they cannot be easily shard among different origins/domains. These kinds of problems can often be solved with some workarounds, yet they will often lead to insecure scenarios to make things work.</li>\n<li>Security issues: There is a wide and detailed literature of security-related issues involving sessions and session cokies:XSS attacks, cross-site request forgery etc. Most of them can be mitigated by some contermeasures, yet they can be diffcult to handle for first-hand developers.</li>\n</ul>\n<h2>Token (stateless)</h2>\n<p>Client - location storage / cookies\nServer - auth check</p>\n<p>advantages:\nIt won’t store any user-specific information of the server memeory, database, session provider,or other data containers of any sort.</p>\n<p><strong>refresh token</strong>\nIt is a special kind of token that can be used to obtain a renewed access token - that allows accessing a protected resource - at any time. You can request new access tokens until the refresh token is blacklisted. Refresh tokens must be stored securely by an application becuase they essentially allow a user to remain authenticated forever.</p>\n<h2>Signatures</h2>\n<h2>Two-factore</h2>\n<ul>\n<li>The user performs a standard login with a useranme and password</li>\n<li>The server identifies the user and prompts them with an additional , user-specific request that can be only satisfied by something obtained or obtainable throught a different channel: an OTP password sent by SMS, an unique authentication card with a number of answer codes, a dynamic PIN generated by a proprietary device or a mobile app, and so on</li>\n<li>If the user gives the correct answer, they get authenticated using a standard session-based or token-based method</li>\n</ul>","frontmatter":{"title":"Notes for authendication!","date":"January 21, 2019"}}},"pageContext":{"slug":"application-application-user-athendication","previous":{"fields":{"slug":"agile"},"frontmatter":{"title":"Agile Notes!"}},"next":{"fields":{"slug":"application"},"frontmatter":{"title":"Application Development Notes!"}}}}