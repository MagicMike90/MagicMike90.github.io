{"data":{"site":{"siteMetadata":{"title":"Michael Blog","author":"Michael Luo"}},"markdownRemark":{"id":"e1f5ddd7-77e2-502e-8f02-4469dec3934f","excerpt":"Frontend technoloy choices : React has shorter learning curve since, it can be impletemented with   a type checking library developed by Facebook, flux pattern…","html":"<h2>Frontend technoloy choices</h2>\n<p><code class=\"language-text\">ReactJS</code>: React has shorter learning curve since, it can be impletemented with <code class=\"language-text\">FlowJS</code> a type checking library developed by Facebook, flux pattern is well supported by <code class=\"language-text\">Redux</code> library.</p>\n<p>There are also some good quality third party CSS framewok, such <code class=\"language-text\">Antd</code>, <code class=\"language-text\">Material UI</code>. However since ReactJS is using virtual DOM to update the view, it will be tricky to integrate those third party libray that manunipulate DOM directly, i.e. D3.JS.</p>\n<p><code class=\"language-text\">AngularJS (2)</code>: Compare to ReactJS, Angular 2/4 is more powerful by implementing TypeScript, one of the benefit is to raise compile time errors. It is more enterprise ready framework, that is why it takes more time for developers to learn.</p>\n<p>Dependency Injection.</p>\n<h2>Backend techology choices</h2>\n<p>NodeJS</p>\n<h2>System architecture</h2>\n<p>Microservices: modularize system services ,it seems to be the trend for system design, since it fits into DevOps team with continouse delivery.</p>\n<ul>\n<li>\n<p>3-Tier architectures</p>\n<ul>\n<li>i.e. MVC architecture</li>\n</ul>\n</li>\n<li>\n<p>4-Tier architectures</p>\n<ul>\n<li>Tier 1: Serverce tier</li>\n<li>Tier 2: Aggregation tier</li>\n<li>Tier 3: Delivery tier</li>\n<li>Aware of client profile (mobile, desktop, IOT, and so on), transforms data delivered by the Aggregation tier into client-specific formats. Cashed data would be fetched here, via CDN or otherwise.Selection of ads to insert into a webpage might be done here. This Tier is reponsible for optimizing data received from the Aggregation tier for an individual user. This layer can often be fully automated.</li>\n<li>Tier 4: Client tier</li>\n</ul>\n</li>\n</ul>\n<h2>Website</h2>\n<p>It is better to use traditional way to create a static sites, simply use JQuery, HTML, CSS and vanalia JavaScript.</p>\n<p>If there are more user interactions, or more UI components have to be managed, more like an application, then I will go with Angular/ React, but in general case, I will choose React, I can see React is exceptional to build widgets.</p>\n<p>Moreover, if I want to build a large platform, for example, a PAAS business, I will choose Angular, due to sctrict type checking, it is imperative to maintain large code base.</p>\n<h2>RAIL model</h2>\n<ul>\n<li>Response: 100 ms to provide a response that acknowledges their action; otherwise, users will notice and get frustrated, and maybe retry the action, causing more problems down the line (we’ve all experienced this—the mad double- and triple-clicking).</li>\n<li>Animation: users will note a lag in animations if they are not performed at 60 fps. This will negatively affect the perceived performance (how the user feels about your app’s speed).</li>\n<li>Idle: Once your application is done loading, it is idle (and also will be idle between actions) until a user performs an action.</li>\n<li>Load: Optimal load time is one second (or less). That doesn’t mean your entire application loads in one second; it means the user sees content within one second. They get some sense that the current task (loading the page) is progressing in a meaningful way, rather than staring at a blank white screen. As we’ll see, this is easier said than done!</li>\n</ul>\n<h2>PRPL pattern</h2>\n<p><strong>PRPL</strong> stands for Push, Render, Pre-cache, Lazy-load; it’s a step-by-step process for how an ideal application should get the content it needs from the server.</p>\n<ul>\n<li>PUSH: A gentle definition of Push can be “load the critical content first, before anything else.</li>\n<li>RENDER: After (ideally) pushing all the necessary resources to the client, we render our initial route</li>\n<li>PRE-CACHED: once those assets are loaded, they will go straight into the cache and, if they’re requested again, we load them from the cache.</li>\n<li>LAZY-LOADED: This means resources needed for other routes will not be loaded.</li>\n</ul>","frontmatter":{"title":"Application Development Notes!","date":"January 21, 2019"}}},"pageContext":{"slug":"application","previous":{"fields":{"slug":"architecture-data-itensive"},"frontmatter":{"title":"Data-intensive Architecture Notes!"}},"next":{"fields":{"slug":"agile"},"frontmatter":{"title":"Agile Notes!"}}}}